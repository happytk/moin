/*
-------------------------------------------------------------------------------------------
  ___ ___ _  _ ___ _____ ___ ___ ___
 | _ \_ _| \| | __|_   _| _ \ __| __| realtime-charting
 |  _/| || .` | _|  | | |   / _|| _|  by Taewook, Kang. SK C&C
 |_| |___|_|\_|___| |_| |_|_\___|___| copyleft. use it anywhere.

------------------------------------------------------------------- generated by ascii art.

coming.
+ alert유지시간표기

version 1.4
+ current_value표시방법 변경 (max-instance-name대신 색깔로 표기)
+ current_value에 data-postfix 설정가능

version 1.3
+ timing_key가 존재하면 server쪽 시간을 이용해서 x축 이동

version 1.2
+ alert을 한번 get에 모아서 보도록
+ data_log를 이용한 초기 그래프 표기
+ olddata check (timing사용시)

version 1.1
+ notification object

version 1.0
+ init.

*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// package initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree = {}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// standard date formatter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.std_dt_fmt = d3.time.format("%Y%m%d%H%M%S");


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// configuration object
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.configuration = function() {
    return {
        system_name: 'NOTITLE',

        //chart-appearance
        width: 100,//(document.body.offsetWidth-20)/4,
        height: 300,
        margin: {top: 30, right: 2, bottom: 2, left: 0},
        interpolate_method: "basis",
        print_header: true,
        print_compact: false,

        //time-range
        n: 190,
        duration: 5000,
        data_get_interval: 5000+100, //duration보다 조금 길어야 graph가 자연스러워짐.

        //data-manipulating
        data_get_url: null,
        data_timing_key: function (d) { return d3.ptree.std_dt_fmt.parse(d._id); },
        data_grouping_key: "inst_id",
        data_filter: null,
        data_key: ["Logrds", "Phyrds", "Exec", "ApCo", "Ats", "Undo_rec", "CPU", "exm%"],
        data_postfix: ["", "", "", "", "", "", "%", "%"],

        //alarming
        data_alarming: true,
        data_alarming_triggers: null
    };
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// sound control
// - singleton pattern - http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.sndctrl = (function (_cfg) {
    var instance;
    function init() {
        // document.getElementById('notification_autio').play();
        var audio = new Audio("/moin_static195/common/n.wav");
        audio.play();
        return audio;
        // notification_sound.play();
    };
    return {
        getInstance: function() {
            if (!instance) {
                instance = init();
            }
            return instance;
        }
    };
})();

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// realtime chart object
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.rtchart = function (_cfg) {
    var cfg = _cfg;
    var data;

    function chart(selection) {

        if (typeof selection == "undefined") {
            selection = d3.select("body").append("div");
        }

        d3.tsv(cfg.data_get_url + '&n=' + cfg.n, function(sample) {

            var system_name = cfg.system_name,
                n = cfg.n,
                duration = cfg.duration,
                now = new Date(Date.now() - duration),
                color = d3.scale.category10(),
                keys,
                notification_time_formatter = d3.time.format("%Y/%m/%d %H:%M"),
                data_format3s = d3.format("0,000"),//(".3s")
                data_old_chain = 0
                ;

            var margin = cfg.margin,
                width = cfg.width - margin.right,
                height = cfg.height - margin.top - margin.bottom;

            var y = d3.time.scale()
                    .range([0,height]);

            //filtering if it is neccesary
            if (cfg.data_filter != null) {
                sample = sample.filter(cfg.data_filter);
            }

            //timemapping
            // sample.forEach(function (d, i) {
            //     d["__time"] = now - duration * (n-i);

            //     //graph가 중간에서 떠 있는걸 막으려면 0부터 올라가도록
            //     // cfg.data_key.map(function (k) {
            //     //     d[k] = 0;
            //     // });
            // });

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //grouping
            //todo: data변형이 일어나면서 tsv format이 깨질 경우 - key값이 undefined인것을 제거할 필요. 20130906
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            data = d3.nest().key(function (d) { return d[cfg.data_grouping_key]; }).sortKeys(d3.ascending).entries(sample);

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //color mapping by instances
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //이 방법보다는 grouping한 데이타를 이용해서
            // var instances = sample.map(function (d, i) { return d[cfg.data_grouping_key]});
            // console.log(instances); --unique 필요  by d3.set?
            // var instances = data.map(function(d) { return d.key; });
            // console.log(instances);
            //color mapping
            //color.domain(data);
            color.domain(data.map(function(d) { return d.key; }));

            //time mapping
            data.forEach(function (d) {
                d.values.forEach(function (dd, i) {
                    if (cfg.data_timing_key == null) {
                        dd["__time"] = now - duration * (n-i);
                    }
                    else {
                        dd["__time"] = cfg.data_timing_key(dd);
                    }
                });
            });

            //x-range
            if (cfg.data_timing_key == null) {
            }
            else {
                //이 경우는 max에서 일정 범위만큼을 사용해야 한다. (min-max가 너무 차이날 경우 대비)
                // x.domain(d3.extent(data, function(d) { return d["__time"]; }));
                now = d3.max(data, function(d) { return d3.max(d.values, function(dd) { return dd["__time"]; }); });
                // console.log('xxxxxxxx', data);
            }
            y.domain([now - (n-2)*duration, now - duration]);
            // console.log(now, [now - (n-2)*duration, now - duration]);
            // console.log(x, x(new Date(Date.now())), x(now-duration));


            keys = cfg.data_key.map(function (k, i) {
                    var _key = k;
                    // var x = d3.scale.linear().range([width,0]);
                    var x = d3.scale.linear().range([0, width]);

                    // path
                    x.domain([
                        d3.min(data, function (d) { //key:grouping_id, values:array
                            return d3.min(d.values, function (dd) { return +dd[k]; }); //각 values의 min을 return
                        }) * 0.9,
                        d3.max(data, function (d) { //key:grouping_id, values:array
                            return d3.max(d.values, function (dd) { return +dd[k]; }); //각 values의 max을 return
                        }) * 1.2
                    ]);

                    return {
                        key:        _key,
                        x:          x,
                        //todo: costly action
                        notification_triggers: cfg.data_alarming_triggers.filter(function(f) { return f.key() == _key; }),
                        pathgen:    d3.svg.line().interpolate(cfg.interpolate_method)
                                    .x(function(xd) { return x(+xd[k]); })
                                    .y(function(yd) { return y(yd.__time); })
                    };
                });


            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // chart base-area (division)
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            var div = selection
                    .attr("id", cfg.system_name)
                ;

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // notification audio
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // <audio id="notification_autio" src="01.mp3"></audio>
            // div.append("audio").attr("id", "notification_audio")
            //     .attr("src", "/moin_static195/common/n.wav");

            // document.getElementById('notification_autio').play();
            // var notification_sound = new Audio("/moin_static195/common/n.wav");
            // notification_sound.play();
            // d3.ptree.sndctrl.getInstance().play();

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // header
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (cfg.print_header) {
                var header = div.append("div").style("background-color", "#efefef")
                    .attr("class", "header")
                    .append("h3")
                    .text(cfg.system_name + ' ')
                    ;

                // console.log(data);
                //1개이상일때만 legend를 보여준다.
                if (data.length > 1) {
                    header.append("span").text("[");
                    header
                            //.append("svg")
                            //.attr("width", 1000)//width + margin.left + margin.right)
                            //.attr("height", 20 )
                            //.selectAll(".legend")
                            .selectAll(".legend")
                            .data(data)
                            .enter()
                            .append("span")
                            .attr("class", "legend")
                            //.attr("transform", function(d, i) { return "translate(" + (i * 70) + ", 0)"; })
                            .style("font-weight", "bold")
                            .style("text-decoration", "underline")
                            .style("color", function(d) { return color(d.key); })
                            .text(function(d) { return d.key; })
                            ;
                    header.append("span").text("]");
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //chartarea 설정
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            var svgs = div.selectAll("p")
                .data(keys, function (d) { return d.key; })
                .enter()
                .append("p")
                .attr("id", "chart")
                .style("float", "left")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("margin-left", margin.left + "px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
                ;

            svgs.append("defs").append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", width)
                .attr("height", height);

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //svg개별로 y축 그리기 (ticks, orient는 설정가능)
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // var yaxis = svgs.append("g")
            //     .attr("class", "y axis")
            //     // .attr("transform", "translate(0," + height + ")")
            //     // .attr("transform", "translate("+width+",0)")
            //     .call(y.axis = d3.svg.axis().scale(y).ticks(10).orient("left"));

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //svg개별로 y축 그리기
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            svgs.each(function (da) {
                var that = d3.select(this);
                var ths_xaxis = that.append("g")
                                .attr("class", "x axis");

                da.x.axis = d3.svg.axis().scale(da.x).ticks(2).tickFormat(d3.format("3s")).orient("bottom");
                da.x.axis(ths_xaxis);

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // key name in rtchart
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // ths_xaxis
                //     .append("text")
                //     // .attr("transform", "rotate(-90)")
                //     .attr("y", 25)
                //     .attr("x", 50)
                //     .attr("id", "chart-title")
                //     // .attr("dy", ".71em")
                //     // .style("text-anchor", "end")
                //     .style("font-family", "Tahoma")
                //     .style("font-weight", "normal")
                //     .style("font-size", "28px")
                //     .style("opacity", "0.2")
                //     // .style("font-weight", "bold")
                //     .text(function () { return da.key; });

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // value in rtchart
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // var chart_max_area = ths_yaxis
                //     .append("text")
                //     // .attr("transform", "rotate(-90)")
                //     .attr("y", 25)
                //     .attr("x", width-10)
                //     .attr("id", "chart-max-value")
                //     // .attr("dy", ".71em")
                //     .style("text-anchor", "end")
                //     .style("font-family", "comic sans ms")
                //     .style("font-size", "28px")
                //     // .style("opacity", "0.6")
                //     // .append('span')
                //     // .attr('id', 'chart-max-area-title')
                //     // .attr('color', color(0))
                //     // .style("font-weight", "bold")
                //     // .style('color', 'red')
                //     .text(function () { return da.key; });

                var path = that.append("g")
                    .attr("clip-path", "url(#clip)")
                    .selectAll("path")
                    .data(data, function (d) { return d.key; })
                    .enter()
                    .append("path")
                    .attr("class", "line")
                    .attr("d", function (d) {
                        // console.log(d.values);
                        // return line(d.values);
                        return da.pathgen(d.values);
                    })
                    .style("opacity", "0.8")
                    .style("stroke", function(d, i) {
                        return color(d.key);
                    });
            });

            //tick the data.
            // tick();
            setInterval(tick, cfg.data_get_interval);

            function tick() {

                //url identifier가 필요한가?
                // d3.tsv(cfg.data_get_url + "&_t" + Date.now(), function(resp) {
                d3.tsv(cfg.data_get_url, function(resp) {

                    var data_healthy = true;
                    var resp_g = {};

                    //now
                    now = new Date(Date.now());

                    // console.log(resp);

                    //resp의 유효성 체크
                    if (resp == undefined || resp.length == 0) {
                        //error message
                        console.log(cfg.system_name, 'Pushed the invalid data.');
                        return;
                    }

                    //filtering if it is neccesary
                    if (cfg.data_filter != null) {
                        resp = resp.filter(cfg.data_filter);
                    }

                    //todo: resp의 시간정보 갱신여부 체크(timing-option-on의 경우)
                    if (cfg.data_timing_key == null) {
                        resp.forEach(function(d) {
                            d["__time"] = now; //new Date(Date.now());
                        });
                    }
                    else {
                        resp.forEach(function(d) {
                            d["__time"] = cfg.data_timing_key(d);
                            if (now - d["__time"] >= 100000) {
                                //data is old
                                //old여도 계속 진행은 한다. (서버시간이 늦거나 local시간이 빠르지만 계속 들어오는 경우)
                                console.log(d[cfg.data_grouping_key], 'data is old.', d["__time"], now - d["__time"]);
                                data_healthy = false;
                            }
                        });

                        //이전 데이타와 같거나 과거 데이타가 들어온다면
                        // console.log(d3.max(resp, function(d) { return d["__time"]; }));
                        // console.log(x.domain()[1]);
                        if (y.domain()[1] >= d3.max(resp, function(d) { return d["__time"]; }) - duration)
                        {
                            data_old_chain += 1;

                            if (data_old_chain >= 5) {
                                //disabled
                                console.log(cfg.system_name, 'Pushed the old data. chart down.', data_old_chain);
                                d3.select("#"+cfg.system_name).transition().duration(1000).style("opacity", "0.4");
                            }
                            // data_healthy = false; --너무 빈번한 화면전환으로 off
                            return; //더 이상 처리할 필요가 없으므로 중지
                        }
                        else {
                            data_old_chain = 0
                        }
                    }

                    //data healthy
                    if (!data_healthy) {
                        // d3.select("#"+cfg.system_name).selectAll(".header").transition().duration(1000).style("color", "#dddddd").style("background-color", "#ffffff");
                        d3.select("#"+cfg.system_name).transition().duration(1000).style("opacity", "0.7");
                    }
                    else {
                        // d3.select("#"+cfg.system_name).selectAll(".header").transition().duration(1000).style("color", "black").style("background-color", "#efefef");
                        d3.select("#"+cfg.system_name).transition().duration(1000).style("opacity", "1.0");
                    }

                    //grouping
                    resp.forEach(function (d) {
                        resp_g[d[cfg.data_grouping_key]] = d;
                    });

                    //grouping_id별로 데이타입력
                    data.forEach(function (d) {
                        //todo: refactoring this code!
                        //var resp2add = resp.filter(function(r) { return r[cfg.data_grouping_key] == d.key; });
                        var resp2add = resp_g[d.key];
                        //todo: 여러개일 가능성이 있는가?
                        // resp2add = resp2add[0];
                        if (resp2add == undefined) {}
                        else {
                            d.values.push(resp2add);
                        }
                    })

                    // console.log(data);

                    // update the domains
                    //x.domain([now - (n - 2) * duration, now - duration]);
                    //x-range
                    if (cfg.data_timing_key == null) {
                    }
                    else {
                        //이 경우는 max에서 일정 범위만큼을 사용해야 한다. (min-max가 너무 차이날 경우 대비)
                        now = d3.max(resp, function(d) { return d["__time"]; });
                        // x.domain(d3.extent(data, function(d) { return d["__time"]; }));
                    }
                    y.domain([now - (n-2)*duration, now - duration]);

                    // slide the line left
                    var alarm_messages = [];
                    svgs.each(function (da, idx) {
                        var that = d3.select(this);

                        // path
                        da.x.domain([
                            d3.min(data, function (d) { //key:grouping_id, values:array
                                return d3.min(d.values, function (dd) { return +dd[da.key]; }); //각 values의 min을 return
                            }) * 0.9,
                            d3.max(data, function (d) { //key:grouping_id, values:array
                                return d3.max(d.values, function (dd) { return +dd[da.key]; }); //각 values의 max을 return
                            }) * 1.2
                        ]);


                        // max value (todo: max_value-instance)
                        var max_val = d3.max(resp, function (d) { return +d[da.key]; });
                        var max_val_grouping_id = resp.filter(function (d) { return +d[da.key] == max_val; });
                        if (max_val_grouping_id.length > 0 && max_val_grouping_id !== 'undefined' && max_val_grouping_id !== null) {
                            max_val_grouping_id = max_val_grouping_id[0][cfg.data_grouping_key];
                            that.select("#chart-max-value")
                                .text("" + data_format3s(max_val) + cfg.data_postfix[idx])
                                .style('fill', color(max_val_grouping_id))
                                // .text("" + max_val_grouping_id + ":" + data_format3s(max_val))
                                ;
                        }
                        // console.log(data, da.key, da.y.domain());
                        that.selectAll(".line")
                            .attr("d", function (d) {
                                // return line(d.values);
                                return da.pathgen(d.values);
                            })
                            .attr("transform", null)
                            .transition()
                            .duration(duration)
                            .ease("linear")
                            .attr("transform", "translate(" + y(now - (n - 1) * duration) + ")")
                            // .each("end", tick)
                            ;

                        that.select(".x")
                            .transition()
                            .duration(800)
                            .ease("linear")
                            .call(da.x.axis);

                        // alarming
                        if (cfg.data_alarming) {
                            var alarm_callback = function (key, group_key, val, limit, limit_chain_val, limit_chain_max)
                            {
                                alarm_messages.push(cfg.system_name + '[' + group_key + '] ' + key + ':' + val  + '>' + limit);
                                d3.select("#"+cfg.system_name).selectAll("svg").data([da], function (d) { return d.key; }).transition().duration(1000).style("background-color", "#ff9999");
                                da.limit_chain_alarmed = true;
                            };

                            var dealarm_callback = function (key, group_key, val, limit, limit_chain_val, limit_chain_max)
                            {
                                d3.select("#"+cfg.system_name).selectAll("svg").data([da], function (d) { return d.key; }).transition().duration(1000).style("background-color", "white");
                                da.limit_chain_alarmed = false;
                            };

                            da.notification_triggers.forEach(function (t) {
                                if (t.valid()) {
                                    t.feedobj(resp_g, alarm_callback, dealarm_callback);
                                }
                            });

                        }
                    });

                    if (alarm_messages.length > 0 && window.webkitNotifications.checkPermission() == 0) {
                        // var alarm_messages_string = "";
                        // for (var i=0; i<alarm_messages.length; i++) {
                        //     alarm_messages_string += alarm_messages[i] + '<br/>';
                        // }
                        //new Notification('PTREE ALERT: ' + notification_time_formatter(now), { 'body': alarm_messages });
                        // notification_sound.play();
                        d3.ptree.sndctrl.getInstance().play();
                    }

                    // slide the x-axis left
                    // yaxis.transition()
                    //     .duration(duration)
                    //     .ease("linear")
                    //     .call(y.axis);

                    // pop the old data point off the front
                    data.map(function(d) {
                        if (d.values.length > n)
                           d.values.shift();
                    });

                    // data.shift();
                    // console.log(x.domain()[0]);
                    // todo: 이런식의 데이타처리는 빠르지가 않다. shift를 유연하게 할 수 있는 방법이 없을까?
                    // data = data.filter(function (d) { return d.tim > x.domain()[0]; });
                }); //end of d3.tsv(resp)

            } //end of function tick

        }); //end of d3.tsv(sample)

    }//end of function chart

    //getter
    chart.data = function() { return data; }
    return chart;
};


d3.ptree.barchart = function(_cfg) {
};

d3.ptree.notification = function(_cfg) {
    var cfg = _cfg;
    var limit_days = d3.set(cfg.limit_days);
    var limit_chain_val = {};
    // var time_formatter = d3.time.format("%H%M")
    var alarm = {};
    var alarmed = {};

    function noti(group_key, val, callback) {
        console.log('Notification', cfg.key, group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        if (callback) {
            callback(cfg.key, group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        }
    }

    alarm.key = function() { return cfg.key; }
    alarm.feedobj = function (obj, alarm_cb, dealarm_cb) {
        //check each group
        var keys = d3.keys(obj);
        var val;
        for (var i=0; i<keys.length; i++) {
            val = +obj[keys[i]][cfg.key];
            this.feedval(keys[i], val, alarm_cb, dealarm_cb);
        }
    }
    alarm.feedval = function (group_key, val, alarm_cb, dealarm_cb) {
        // console.log(group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        if (val >= cfg.limit) {
            if (!limit_chain_val[group_key])
                limit_chain_val[group_key] = 1;
            else
                limit_chain_val[group_key] += 1;
        } else {
            limit_chain_val[group_key] = 0;
            if (alarmed[group_key]) {
                noti(group_key, val, dealarm_cb);
                alarmed[group_key] = false;
            }
        }
        if (limit_chain_val[group_key] >= cfg.limit_chain_max) {
            if (!alarmed[group_key]) {
                noti(group_key, val, alarm_cb);
                alarmed[group_key] = true;
            }
        }
    }
    alarm.valid = function () {
        var now = new Date(Date.now());
        var now_day = now.getDay();
        var now_hour = now.getHours();
        var now_min = now.getMinutes();
        var now_hm = "";
        if (now_min < 10)
            now_min = "0" + now_min;
        if (now_hour < 10)
            now_hour = "0" + now_hour;
        now_hm = "" + now_hour + now_min;

        var v = false;
        //day check
        if (limit_days.has(now_day)) {
            v = true;
        }
        else { v = false; }
        //time check
        if (now_hm >= cfg.limit_time_range[0] &&
            now_hm <= cfg.limit_time_range[1]) {
            v = true;
        }
        else { v = false; }
        // console.log('valid', v);
        return v;
    }
    return alarm;
};

// MVNO
var __ptree_conf_mvno = d3.ptree.configuration();
__ptree_conf_mvno["system_name"] = "MVNO";
__ptree_conf_mvno["data_get_url"] = "/__tsv_dataset/mvno?action=pythonruntime";
__ptree_conf_mvno["data_filter"] = function(d) { return d.inst_id == 'mvno1'; };
__ptree_conf_mvno["data_alarming_triggers"] = [
    d3.ptree.notification({key: 'logrds', limit: 200000, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
    d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
];
d3.ptree.rtchart(__ptree_conf_mvno)();
