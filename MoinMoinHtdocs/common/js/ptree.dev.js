/*
-------------------------------------------------------------------------------------------
  ___ ___ _  _ ___ _____ ___ ___ ___
 | _ \_ _| \| | __|_   _| _ \ __| __| realtime-charting
 |  _/| || .` | _|  | | |   / _|| _|  by Taewook, Kang. SK C&C
 |_| |___|_|\_|___| |_| |_|_\___|___| copyleft. use it anywhere.

------------------------------------------------------------------- generated by ascii art.


version 1.8 (coming.)
+ grouping, sum, avg 옵션을 사용할 수 있도록 (시간축이 미묘하게 조금씩 다를경우 가능할까?)
+ tick에서 가져오는 데이타가 대량일 수 있게 변하면서 max값 추출하는 로직이 변경 필요 (가장 마지막의 max)

version 1.7
+ duration으로 임의이동하지 않고, 항상 data 전후 기준만큼만 x축, 그래프 이동
+ setInterval을 사용하면 background에서도 계속 동작하지만 d3 chart는 inactive시에는 움직이지 않는다.
  따라서 d3의 each function을 이용해서 transition이 끝나는 시점에만 tick 호출
  (inactive구간의 데이타를 한꺼번에 받아올 필요가 있다.)
+ inactive구간의 데이타를 한꺼번에 받아오도록
+ referenced_chart는 mean값을 이용하도록 수정

version 1.6
+ data_key기준으로 환경설정구성
+ data_key별 size조절
+ 과거히스토리 조회용 data_key
+ data_key별 item

version 1.5
+ frame을 먼저 그리고 data loading.
+ jslint applied
+ 성능개선을 위한 local변수처리

version 1.4
+ current_value표시방법 변경 (max-instance-name대신 색깔로 표기)
+ current_value에 data-postfix 설정가능

version 1.3
+ timing_key가 존재하면 server쪽 시간을 이용해서 x축 이동

version 1.2
+ alert을 한번 get에 모아서 보도록
+ data_log를 이용한 초기 그래프 표기
+ olddata check (timing사용시)

version 1.1
+ notification object

version 1.0
+ init.

*/
/*jslint indent: 4 */
/*globals window */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// resize event!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
window.onresize = function () { window.location.href = window.location.href + ""; };

/*globals d3 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// package initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree = {};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// standard date formatter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.std_dt_fmt = d3.time.format("%Y%m%d%H%M%S");

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// sound control
// - singleton pattern - http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.sndctrl = (function (_cfg) {
    var instance;

    function init() {
        //document.getElementById('notification_autio').play();
        /*globals Audio*/
        var audio = new Audio("/moin_static195/common/n.wav");
        audio.play();
        return audio;
        // notification_sound.play();
    }

    return {
        getInstance: function () {
            if (!instance) {
                instance = init();
            }
            return instance;
        }
    };
}());


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// configuration object
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.configuration = function () {
    return {
        system_name: 'NOTITLE',         //div의 id로 사용되므로 특수문자나 한글 금지

        //chart-appearance
        // width: (document.body.offsetWidth - 20) / 4,
        // height: 80,
        margin: {
            top: 0,
            right: 0,
            bottom: 2,
            left: 0
        },
        interpolate_method: "basis",    //chart그리는 방법 (d3option)
        print_header: true,             //system_name이 표시되는 bar 표시여부

        //time-range
        n: 190,                         //chart에 표시할 가로 entry 개수
        duration: 7000,                 //data polling, drawing interval

        //data-manipulating
        data_key: "deacon_ukyp",        //datastorage에서 참고할 데이타의 key
        data_grouping_cnt: 6,           //datastorage에서 참고할 데이타의 group개수
        data_grouping_key: "inst_id",   //datastorage에서 grouping_id
        data_get_url: "/__ptree?",      //datastorage url
        data_ref_url: "/__ptree_ref?",  //datastorage url(reference)
        data_timing_key: function (d) { //data의 timing key를 결정하는 function
            return d3.ptree.std_dt_fmt.parse(d._id);
        },
        data_filter: null,              //data의 후처리 filter function

        //chart로 표시할 data columns 설정 (deacon)
        data_columns: [
            {key: 'Logrds',   postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 4, height: 88, charttype: 'line'},
            {key: 'ApCo',     postfix: 's', width: (document.body.offsetWidth - 20) / 16 * 4, height: 88, charttype: 'line',
                notifications: [
                    {limit: 30, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
                ]},
            {key: 'CPU',      postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8 / 3, height: 88, charttype: 'line',
                notifications: [
                    {limit: 95, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
                ]},
            {key: 'Phyrds',   postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 8 / 3, height: 88, charttype: 'line'},
            {key: 'Undo_rec', postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 8 / 3, height: 88, charttype: 'line'},
            {key: 'Exec',     postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 4,   height: 88, charttype: 'line'},
            {key: 'Ats',      postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 4,   height: 88, charttype: 'line'},

            //reference용 chart만들기
            //dailyref에 참고하고 싶은 수치를 넣는다.
            {key: 'drLogrds', postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 4,   height: 88, charttype: 'line', dailyref: 'Logrds' },
            {key: 'drExec',   postfix: '',  width: (document.body.offsetWidth - 20) / 16 * 4,   height: 88, charttype: 'line', dailyref: 'Exec' }
        ],

        //chart로 표시할 data columns 설정 (glance)
        // data_columns: [
        //     {key: 'cpu',        postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line',
        //         notifications: [
        //             {limit: 90, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
        //         ]},
        //     {key: 'mem',        postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
        //     {key: 'disk',       postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line',
        //         notifications: [
        //             {limit: 90, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
        //         ]},
        //     {key: 'disk_phy_read_byte',  postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
        //     {key: 'disk_phy_write_byte', postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
        //     {key: 'disk_phy_byte',       postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
        // ],

        //alarming
        data_alarming: true,
        data_alarming_bgcolor: '#ff5555'
    };
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//sample validation
//todo: sample 값이 유효한지 검사 필요
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.data_group_clean = function (cfg, data, timed_func) {

    if (!data || data.length === 0) {
        return;
    }

    //filtering if it is neccesary
    if (cfg.data_filter) {
        data = data.filter(cfg.data_filter);
    }

    //applying time-function
    if (!timed_func) {
        timed_func = cfg.data_timing_key;
    }

    data.forEach(function (d, i) {
        d.__time = timed_func(d, i);
    });

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //grouping using d3.nest
    //todo: data변형이 일어나면서 tsv format이 깨질 경우 - key값이 undefined인것을 제거할 필요. 20130906
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    data = d3.nest().key(function (d) {
        return d[cfg.data_grouping_key];
    }).sortKeys(d3.ascending).entries(data);

    return data;
};

d3.ptree.data_group_mean = function (sample_t, key) {

    if (!sample_t)
        return;

    //grouped(value)
    sample_t = sample_t.map(function (d, i) {
        return d.values;
    });

    sample_t = d3.zip.apply(this, sample_t)

    //average
    sample_t = sample_t.map(function (d, i) {
        return {
            // _id: d[0]._id,
            __time: d[0].__time,
            mean: d3.mean(d, function(e) { return +e[key]; })
        };
    });

    //기존 sample_t와 구조를 맞추어준다. (d3.nest의 결과물처럼)
    return [{ key: 'mean', values: sample_t }];
};


d3.ptree.grouping_data_last_prev_min = function (g, key) {
    return d3.min(g, function (d) {
        return d.values[d.values.length-2][key];
    });
}

d3.ptree.grouping_data_last_prev_max = function (g, key) {
    return d3.min(g, function (d) {
        return d.values[d.values.length-2][key];
    });
}

d3.ptree.grouping_data_last_min = function (g, key) {
    return d3.min(g, function (d) {
        return d.values[d.values.length-1][key];
    });
};

d3.ptree.grouping_data_last_max = function (g, key) {
    return d3.max(g, function (d) {
        return d.values[d.values.length-1][key];
    });
};

d3.ptree.grouping_data_last_max_and_gid = function (g, key) {
    var prev = 0;
    var gid = null;
    var i = 1;
    g.forEach(function(d, di) {
        var v = +d.values[d.values.length-1][key] || 0;
        v = Math.max(prev, v);
        if (v !== prev) {
            prev = v;
            gid = d.key;
            i = di;
        }
    });
    return {
        max: prev,
        i: i,
        gid: gid
    };
}

d3.ptree.grouping_data_first_min = function (g, key) {
    return d3.min(g, function (d) {
        return d.values[0][key];
    });
}

d3.ptree.grouping_data_first_max = function (g, key) {
    return d3.max(g, function (d) {
        return d.values[0][key];
    });
}

d3.ptree.grouping_data_first_next_min = function (g, key) {
    return d3.min(g, function (d) {
        return d.values[1][key];
    });
}

d3.ptree.grouping_data_first_next_max = function (g, key) {
    return d3.max(g, function (d) {
        return d.values[1][key];
    });
}

d3.ptree.grouping_data_min = function (g, key) {
    return d3.min(g, function (d) {
        return d3.min(d.values, function (dd) {
            return +dd[key];
        });
    });
};

d3.ptree.grouping_data_max = function (g, key) {
    return d3.max(g, function (d) {
        return d3.max(d.values, function (dd) {
            return +dd[key];
        });
    });
};


d3.ptree.append_path = function (that, id, data, pathgen, opacity, color) {
    return that.append("g")
        .attr("id", id)
        .selectAll("path")
        .data(data, function (d) { return d.key; })
        .enter()
        .append("path")
        .attr("class", "line")
        .attr("d", function (d) { return pathgen(d.values); })
        .style("opacity", opacity)
        .style("stroke", function (d) { return color(d.key); });
};


d3.ptree.refchart = function (cfg, da, that, now) {

    /*

    refchart는 전일자와 오늘자를 비교해야 하기 때문에,
    시간값만 빼어서 임의의 같은 날자로 맞춰주어야 한다.

    now와 da.da.dailyref_last_dt를 보고, 전일자를 갱신할 것인지, 오늘자를 갱신할 것인지 판단한다.
    전일자는 날짜로 비교,
    오늘자는 분으로 비교(혹은 시간)

    now, last_oper_dt는 Date object를 가진다.

    */
    var today,
        yesterday,
        time_range,
        tf_ymdhms_parse,
        tf_ymdhm,
        tf_ymd,
        base_dt,
        base_tm,
        base_dtm,
        ref_url_y,
        ref_url_t,
        color = d3.scale.category10();

    //시간 format
    tf_ymdhms_parse = d3.time.format('%Y%m%d%H%M%S').parse;
    tf_ymdhm = d3.time.format('%Y%m%d%H%M');
    tf_ymd = d3.time.format('%Y%m%d');

    //오늘데이타 조회 판단 - last_oper_dt와 분이 다르면, 즉 1분마다 수행
    if (da.dailyref_last_dt && tf_ymdhm(da.dailyref_last_dt) === tf_ymdhm(now)) {
        return;
    }

    //어제일자와 오늘일자
    yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday = d3.time.format('%Y%m%d')(yesterday);

    today = d3.time.format('%Y%m%d')(new Date(now));

    //표시할 시간범위
    time_range = ['090000', '200000'];

    //차트에 표시할 기준일자(임의선정)
    base_dt = '19810130'

    //차트에 표시할 기준시간(오늘자는 base_tm전까지의 데이타를 가져온다.)
    base_tm = tf_ymd(new Date(now));
    if (base_tm < time_range[0]) {
        base_tm = time_range[0];
    }
    if (base_tm > time_range[1]) {
        base_tm = time_range[1];
    }

    //차트의 기준시간(yyyymmddhhmiss)
    base_dtm = tf_ymdhms_parse(base_dt + base_tm);

    //차트의 x축 시간범위설정
    da.x.domain([tf_ymdhms_parse(base_dt + time_range[0]), tf_ymdhms_parse(base_dt + time_range[1])])

    //x축 그리기
    da.xaxis.call(da.x.axis);

    //오늘의 기준시간 전까지의 데이타 가져오기
    ref_url_t = da.dailyref_url +
                '&b=' + time_range[0] +
                '&e=' + base_tm +
                '&n=' + today +
                '&s=' + parseInt(d3.max([parseInt(+da.x(base_dtm)), 0])/1);

    //어제일자의 범위시간 데이타 가져오기
    ref_url_y = da.dailyref_url +
                '&b=' + time_range[0] +
                '&e=' + time_range[1] +
                '&n=' + yesterday +
                '&s=' + parseInt(d3.max([parseInt(+da.width), 0])/1);


    //오늘데이타 조회
    d3.tsv(ref_url_t, function(sample_t) {

        var daily_proc_func = function (d, i) {
            return tf_ymdhms_parse(base_dt + d._id.substring(8));
        };
        var da_key = 'mean';

        //grouped(key, value)
        sample_t = d3.ptree.data_group_clean(cfg, sample_t, daily_proc_func);

        //grouped(key, mean-value)
        sample_t = d3.ptree.data_group_mean(sample_t, da.key);


       var drawing_refchart = function (sample_y, sample_t) {

            // //어제가 많다는 가정하에 y기준으로 t 합치기
            // var sample = sample_y.map(function (d, i) {
            //     return {
            //         v1: d.mean,
            //         v2: sample_t[i].mean,
            //         t1: d.__time,
            //         t2: sample_t[i].mean
            //     };
            // });

            // da.y.domain(
            //     [
            //     d3.min(sample, function(d) { return Math.min(d.v1, d.v2); }),
            //     d3.max(sample, function(d) { return Math.max(d.v1, d.v2); })
            //     ]
            // );

            // that.selectAll('#daily-ref-clip').remove();
            // that.selectAll('#clip-below').remove();
            // that.selectAll('#clip-above').remove();

            // da.yaxis.call(da.y.axis);


            // var line = d3.svg.area()
            //     .interpolate("basis")
            //     .x(function(d) { return da.x(d.t1); })
            //     .y(function(d) { return da.y(d.v1||0); });

            // var area = d3.svg.area()
            //     .interpolate("basis")
            //     .x(function(d) { return da.x(d.t1); })
            //     .y1(function(d) { return da.y(d.v1||0); });

            // that.datum(sample);
            // that.append("clipPath")
            //     .attr("id", "clip-below")
            //     .append("path")
            //     .attr("d", area.y0(88));

            // that.append("clipPath")
            //     .attr("id", "clip-above")
            //     .append("path")
            //     .attr("d", area.y0(0));

            // that.append("path")
            //     .attr("class", "area above")
            //     .attr("clip-path", "url(#clip-above)")
            //     .attr("d", area.y0(function(d) { return da.y(d.v2); }));

            // that.append("path")
            //     .attr("class", "area below")
            //     .attr("clip-path", "url(#clip-below)")
            //     .attr("d", area);

            // that.append("path")
            //     .attr("class", "line")
            //     .attr("d", line);


            if (sample_t && sample_y) {
                da.y.domain([
                            d3.min([d3.ptree.grouping_data_min(sample_t, da_key),
                                    d3.ptree.grouping_data_min(sample_y, da_key)]) * 0.9,
                            d3.max([d3.ptree.grouping_data_max(sample_t, da_key),
                                    d3.ptree.grouping_data_max(sample_y, da_key)]) * 1.1
                            ]);
            } else if (sample_t) {
                da.y.domain([d3.ptree.grouping_data_min(sample_t, da_key) * 0.9,
                             d3.ptree.grouping_data_max(sample_t, da_key) * 1.1]);
            } else if (sample_y) {
                da.y.domain([d3.ptree.grouping_data_min(sample_y, da_key) * 0.9,
                             d3.ptree.grouping_data_max(sample_y, da_key) * 1.1]);
            } else {
                return;
            }

            //y기준으로 시간 통일하기 -- diff를 정교하게 그리기 위해
            // sample_t.forEach(function (d, i) {
            //     d.__time = sample_y[i].__time;
            // });

            that.selectAll('#daily-ref-clip').remove();
            that.selectAll('#clip-below').remove();
            that.selectAll('#clip-above').remove();

            //y축 그리기
            da.yaxis.call(da.y.axis);

            //graph그리기
            da.pathgen = d3.svg.area().interpolate(cfg.interpolate_method)
                            .x(function(d) { return da.x(d.__time); })
                            .y(function(d) { return da.y(+d[da_key]) || 0; });

            if (sample_t) {
                d3.ptree.append_path(that, 'daily-ref-clip', sample_t, da.pathgen, '0.8', color);
            }
            if (sample_y) {
                d3.ptree.append_path(that, 'daily-ref-clip', sample_y, da.pathgen, '0.3', color);
            }

            // //diff를 위한 area
            // da.pathgen_area = d3.svg.area().interpolate(cfg.interpolate_method)
            //                 .x(function(d) { return da.x(d.__time); })
            //                 .y1(function(d) { return da.y(+d[da_key]) || 0; })
            //                 ;
            // da.pathgen_area_diff = d3.svg.area().interpolate(cfg.interpolate_method)
            //                 .y1(function(d) { return da.y(+d[da_key]) || 0; })
            //                 // .x(function(d) { return da.x(d.__time); })
            //                 ;


            // that.datum(sample_y[0]);
            // that.datum(sample_t[0]);
            // da.values = sample_t[0].values;
            // da.values_diff = sample_y[0].values;

            // that.append("clipPath")
            //     .attr("id", "clip-below")
            //     .append("path")
            //     // .attr("d", function (d) { return da.pathgen_area(d.values); });
            //     // .style("fill", color(0))
            //     // .attr("d", da.pathgen_area.y0(3))
            //     .attr("d", function (d) { return da.pathgen_area.y0(88)(d.values); })
            //     ;

            // that.append("clipPath")
            //     .attr("id", "clip-above")
            //     .append("path")
            //     // .attr("d", function (d) { return da.pathgen_area(d.values_diff); });
            //     .attr("d", function (d) { return da.pathgen_area.y0(0)(d.values); })
            //     ;
            //     // console.log(da.pathgen_area.y0(3));

            // that.append("path")
            //     .attr("id", "daily-ref-clip")
            //     .attr("class", "area above")
            //     .attr("clip-path", "url(#clip-above)")
            //     .attr("d", function (d) { return da.pathgen_area_diff.y0(function (x, i) {
            //         if (d.values_diff[i])
            //             return da.y(+d.values_diff[i][da_key]||0) || 0;
            //         else
            //             return da.y(0) || 0;
            //     })
            //     .x(function (x, i) {
            //         if (d.values_diff[i])
            //             return da.x(d.values_diff[i].__time);
            //         else
            //             return da.x(d.values[i].__time);
            //     })
            //     (d.values); })
            //     .style("opacity", "0.5");

            // that.append("path")
            //     .attr("id", "daily-ref-clip")
            //     .attr("class", "area below")
            //     .attr("clip-path", "url(#clip-below)")
            //     .attr("d", function (d) { return da.pathgen_area(d.values); })
            //     .style("opacity", "0.5");

            // that.append("path")
            //     .attr("id", "daily-ref-clip")
            //     // .attr("class", "line")
            //     .attr("d", function (d) { return da.pathgen(d.values); })
            //     // .style("stroke", rgb(252,141,89))//color(0))
            //     .style("stroke", color(0))
            //     .style("stroke-width", "0.5px");

            // that.append("path")
            //     .attr("id", "daily-ref-clip")
            //     // .attr("class", "line")
            //     .attr("d", function (d) { return da.pathgen(d.values_diff); })
            //     // .style("stroke", rgb(145,207,96))//color(1))
            //     .style("stroke", color(1))
            //     .style("stroke-width", "0.5px");


            da.dailyref_last_dt = new Date(now);
        };

        //어제 데이타 조회 판단
        //어제 데이타를 가져오지 않으려면 데이타를 cache해두고 있어야 한다.
        //오늘 데이타의 크기에 따라 domain이 바뀌어서 다시 그려주어야 할 수도 있기 때문
        //매번 다시가져오거나 혹은 데이타를 cache해두거나 결정해야 한다.
        if (da.dailyref_last_dt && tf_ymd(da.dailyref_last_dt) === tf_ymd(now)) {
            // console.log('cached?', da.dailyref_last_dt);
            sample_y = da.dailyref_ydata;
            drawing_refchart(sample_y, sample_t);
        }
        else {

            d3.tsv(ref_url_y, function(sample_y) {

                sample_y = d3.ptree.data_group_clean(cfg, sample_y, daily_proc_func);
                sample_y = d3.ptree.data_group_mean(sample_y, da.key);

                //재활용할 수 있도록 보존해둔다
                da.dailyref_ydata = sample_y;
                drawing_refchart(sample_y, sample_t);
            });
        }


    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// realtime chart object
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3.ptree.rtchart = function (_cfg) {
    var cfg = _cfg;

    //default proc.
    cfg.data_get_url = cfg.data_get_url + '&k=' + cfg.data_key + '&c=' + cfg.data_grouping_cnt;

    function chart(selection) {

        if (selection === undefined) {
            selection = d3.select("body").append("div");
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //configuration
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        var keys = cfg.data_columns.map(function (d, i) {
                var _key = d.key;
                var _y = d3.scale.linear().range([d.height, 0]);
                var _x = d3.time.scale().range([0, d.width]);
                d.notifications = d.notifications || [];
                if (d.dailyref) {
                    ///__tsv_dataset/__ref?action=pythonruntime&k=deacon_ukyp&c=5&dk=Logrds&sk=drLogrds'
                    d.dailyref_url = cfg.data_ref_url + '&k=' + cfg.data_key + '&c=' + cfg.data_grouping_cnt + '&dk=' + d.dailyref + '&sk=' + d.key;
                }
                return {
                    key: _key,
                    x: _x,
                    y: _y,
                    width: d.width,
                    height: d.height,
                    format_postfix: d.postfix,
                    notification_triggers: d.notifications.map(function (d) {
                        d.key = _key;
                        return d3.ptree.notification(d);
                    }),
                    dailyref_url: d.dailyref_url,
                    dailyref_last_dt: null
                };
            });

        //d3.tsv전에 frame을 그리기
        var margin = cfg.margin;

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // chart base-area (division)
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        var div = selection
            .attr("id", cfg.system_name);

        var header = div.append("div")
            .attr("class", "header")
            .append("h4")
            .text(cfg.system_name + ' ');

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //chartarea 설정
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        var svgs = div.selectAll("p")
            .data(keys, function (d) {
                return d.key;
            })
            .enter()
            .append("p")
            .attr("id", "chart")
            .append("svg")
            // .attr("width", width + margin.left + margin.right)
            // .attr("height", height + margin.top + margin.bottom)
            .attr("width", function (d) { return d.width + margin.left + margin.right; })
            .attr("height", function (d) { return d.height + margin.top + margin.bottom; })
            .style("margin-left", margin.left + "px")
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // svgs.append("defs").append("clipPath")
        //     .attr("id", "clip")
        //     .append("rect")
        //     .attr("width", width)
        //     .attr("height", height);

        svgs.each(function (da) {
            var that = d3.select(this);
            var ths_yaxis = that.append("g")
                .attr("class", "y axis");

            da.y.axis = d3.svg.axis().scale(da.y).ticks(2).tickFormat(d3.format("3s")).orient("right");
            da.y.axis(ths_yaxis);

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // key name in rtchart
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ths_yaxis
                .append("text")
                // .attr("transform", "rotate(-90)")
                .attr("y", 25)
                .attr("x", 50)
                .attr("id", "chart-title")
                .text(function () {
                    return da.key;
                });

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // value in rtchart
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (!da.dailyref_url) {
                ths_yaxis
                    .append("text")
                    // .attr("transform", "rotate(-90)")
                    .attr("y", 25)
                    .attr("x", da.width - 10)
                    .attr("id", "chart-max-value")
                    // .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .style("font-family", "comic sans ms")
                    .style("font-size", "28px")
                    .text("...");
            }
            da.yaxis = ths_yaxis;

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //svg개별로 x축 그리기 (ticks, orient는 설정가능)
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            da.xaxis = that.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + da.height + ")")
                .call(da.x.axis = d3.svg.axis().scale(da.x).ticks(6).orient("top"));
        });

        d3.tsv(cfg.data_get_url + '&n=' + cfg.n, function (sample) {

            var n = cfg.n,
                duration = cfg.duration,
                now,
                color = d3.scale.category10(),
                data_format3s = d3.format("0,000"), //(".3s")
                data_old_chain = 0,
                data_dt_last_max = null,
                data_dt_last_prev_max = null,
                data_dt_first_min = null,
                data_dt_first_next_min = null,
                data,
                ref_chart_dt = null;

            now = new Date(Date.now() - duration);
            if (!cfg.data_timing_key) {
                cfg.data_timing_key = function (d, i) {
                    return now - duration * (n - i);
                };
            }
            data = d3.ptree.data_group_clean(cfg, sample);
            if (!data || data.length === 0) {
                header.append('span')
                        .style('color', 'red')
                        .text("No data.");
                return;
            }

            if (data[0].key === "undefined" && cfg.data_grouping_key !== null) {
                //validation - grouping에 실패했고, 실제 환경설정은 grouping_key를 지정했을때
                header.append('span')
                        .style('color', 'red')
                        .text("Failed to grouping.");
                return;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //color mapping by instances
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            color.domain(data.map(function (d) {
                return d.key;
            }));

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //x-range
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            data_dt_last_max = d3.ptree.grouping_data_last_max(data, '__time');
            data_dt_last_prev_max = d3.ptree.grouping_data_last_prev_max(data, '__time');
            data_dt_first_min = d3.ptree.grouping_data_first_min(data, '__time');
            data_dt_first_next_min = d3.ptree.grouping_data_first_next_min(data, '__time');

            if (cfg.data_timing_key) {
                //이 경우는 max에서 일정 범위만큼을 사용해야 한다. (min-max가 너무 차이날 경우 대비)
                // x.domain(d3.extent(data, function (d) { return d.__time; }));
                // now = data_prev_dt_max - duration;
                now = data_dt_last_prev_max;
            }


            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // header
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (cfg.print_header) {
                //1개이상일때만 legend를 보여준다.
                if (data.length > 1) {
                    header.append("span").text("[");
                    header
                        .selectAll(".legend")
                        .data(data)
                        .enter()
                        .append("span")
                        .attr("class", "legend")
                        .style("font-weight", "bold")
                        .style("text-decoration", "underline")
                        .style("color", function (d) {
                            return color(d.key);
                        })
                        .text(function (d) {
                            return d.key;
                        });
                    header.append("span").text("]");
                }
            }


            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //svg개별로 y축 그리기
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            svgs.each(function (da) {
                var that = d3.select(this);

                if (da.dailyref_url || da.values) {

                    //dailyref는 배경색을 다르게!
                    d3.select(that[0][0].parentNode.parentNode).style('background-color', '#efffff');

                    // var dailyref_f = function() {
                    d3.ptree.refchart(cfg, da, that, now);
                    // };

                    // dailyref_f();
                    // setInterval(dailyref_f, 1000 * 60 * 5);

                } else {

                    //xaxis
                    // da.x.domain([now - (n - 2) * duration, now - duration]);

                    da.x.domain([data_dt_first_min, data_dt_last_prev_max]);
                    da.xaxis.call(da.x.axis);

                    //yaxis
                    da.y.domain([d3.ptree.grouping_data_min(data, da.key) * 0.9,
                                 d3.ptree.grouping_data_max(data, da.key) * 1.2]);
                    da.yaxis.call(da.y.axis);

                    //paths
                    da.pathgen = d3.svg.line().interpolate(cfg.interpolate_method)
                                    .x(function (d) { return da.x(d.__time); })
                                    .y(function (d) { return da.y(+d[da.key]) || 0; });
                    d3.ptree.append_path(that, '', data, da.pathgen, '0.8', color);

                    //alarming
                    if (cfg.data_alarming) {
                        da.alarm_obj = d3.select(that[0][0].parentNode.parentNode); //g -> svg -> div
                        da.alarm_callback = function (d) {
                            da.alarm_obj.transition().duration(1000).style("background-color", cfg.data_alarming_bgcolor);
                            d3.ptree.sndctrl.getInstance().play();
                        };

                        da.dealarm_callback = function (d) {
                            da.alarm_obj.transition().duration(1000).style("background-color", "white");
                        };
                    }
                }
            });


            function tick() {

                //version1.8
                //서버 최신에서 data_dt_last_max까지 최대 n개 가져와야 의미가 있다.
                d3.tsv(cfg.data_get_url + '&last_dt='+d3.ptree.std_dt_fmt(data_dt_last_max) + '&n=' + cfg.n, function (resp) {
                // d3.tsv(cfg.data_get_url, function (resp) {

                    var resp_g = {};
                    var now_max;
                    var first = true;

                    //resp의 유효성 체크
                    if (!resp || resp.length === 0) {
                        //error message
                        // console.log('The received data is empty.', cfg.system_name, resp);

                        data_old_chain += 1;

                        if (data_old_chain === 5) {
                            div.transition().duration(1000).style("opacity", "0.4");
                        }

                        setTimeout(tick, duration);
                        return;
                    }

                    //filtering if it is neccesary
                    if (cfg.data_filter) {
                        resp = resp.filter(cfg.data_filter);
                    }

                    if (cfg.data_timing_key === null || cfg.data_timing_key === undefined) {
                        now_max = new Date(Date.now());
                        resp.forEach(function (d) {
                            d.__time = now_max;
                        });
                    } else {
                        resp.forEach(function (d) {
                            d.__time = cfg.data_timing_key(d);
                            // if (now - d.__time >= 100000) {
                            //     //data is old
                            //     //old여도 계속 진행은 한다. (서버시간이 늦거나 local시간이 빠르지만 계속 들어오는 경우)
                            //     console.log(d[cfg.data_grouping_key], 'data is old.', d.__time, now - d.__time);
                            //     data_healthy = false;
                            // }
                        });
                        now_max = d3.max(resp, function (d) { return d.__time; });

                        //이전 데이타와 같거나 과거 데이타가 들어온다면
                        // console.log(d3.max(resp, function (d) { return d.__we; }));
                        // console.log(x.domain()[1]);
                        // if (data_dt_last_max.toUTCString() === now_max.toUTCString()) {
                        if (+data_dt_last_max >= +now_max) {
                            data_old_chain += 1;

                            if (data_old_chain === 5) {
                                div.transition().duration(1000).style("opacity", "0.4");
                            }
                            console.log(cfg.system_name, 'Pushed the old data.', data_old_chain);
                            setTimeout(tick, duration);
                            return; //더 이상 처리할 필요가 없으므로 중지
                        }
                        else {
                            if (data_old_chain > 0) {
                                div.transition().duration(1000).style("opacity", "1.0");
                                data_old_chain = 0;
                            }
                        }
                    }

                    //todo: !!CRITICAL!! resp -> data에 넣는 로직은 개선이 필요하다.
                    //asis:
                    //
                    // data -- grouping_id1 -- [old_object1, old_object2, old_object3, old_object4 ...]
                    //      -- grouping_id2 -- [old_object1, old_object2, old_object3, old_object4 ...]
                    //      -- grouping_id3 -- [old_object1, old_object2, old_object3, old_object4 ...]
                    //      -- grouping_id4 -- [old_object1, old_object2, old_object3, old_object4 ...]
                    //
                    // resp -- [group1_new_object, group2_new_object, group3_new_object ..]
                    //
                    // resp_g -- grouping_id1 -- new_object1
                    //           grouping_id2 -- new_object2
                    //           grouping_id3 -- new_object3
                    //           grouping_id4 -- new_object4

                    //grouping data에 추가 - 순서대로 들어온다고 가정하므로 따로 정렬은 하지 않는다.
                    resp.forEach(function (new_d) {
                        resp_g[new_d[cfg.data_grouping_key]] = new_d;   //todo: please remove! --현재는 alarming을 위해 사용중이므로 (마지막 값을 dict로 보존)
                        data.forEach(function (grp_d) {
                            if (grp_d.key === new_d[cfg.data_grouping_key]) {
                                grp_d.values.push(new_d);
                            }
                        });
                    });

                    // //grouping_id별로 데이타입력
                    // data.forEach(function (d) {
                    //     var resp2add = resp_g[d.key];

                    //     //여러개일 가능성이 있는가? --여러개여도 grouping에서 마지막 내용이 들어가게 된다.
                    //     if (resp2add) {
                    //         d.values.push(resp2add);
                    //     }
                    // });

                    //http://stackoverflow.com/questions/13465796/d3-javascript-difference-between-foreach-and-each
                    //with d3's each function, you get more than just d, i -> this keyword.
                    svgs.each(function (da, idx) {

                        var that = d3.select(this),
                            key = da.key,
                            max_val,
                            max_val_grouping_id,
                            transitions
                            ;

                        if (da.dailyref_url || da.values) {

                            d3.ptree.refchart(cfg, da, that, now_max);

                        }
                        else {
                            // da.x.domain([now - (n - 2) * duration, now - duration]);
                            // console.log(da);
                            da.x.domain([data_dt_first_next_min, data_dt_last_max]);

                            // slide the x-axis left
                            if (first) {
                                da.xaxis.transition()
                                    .duration(duration)
                                    .ease("linear")
                                    .call(da.x.axis)
                                    .each("end", tick); //다음 tick호출 예약
                                first = false; //tick이 여러번 호출되지 않도록 체크
                            }
                            else {
                                da.xaxis.transition()
                                    .duration(duration)
                                    .ease("linear")
                                    .call(da.x.axis);
                            }

                            da.y.domain([d3.ptree.grouping_data_min(data, da.key) * 0.9,
                                         d3.ptree.grouping_data_max(data, da.key) * 1.2]);

                            da.yaxis.transition()
                                .duration(800)
                                .ease("linear")
                                .call(da.y.axis);

                            // max value (todo: max_value-instance)
                            max_val = d3.ptree.grouping_data_last_max_and_gid(data, da.key);
                            // max_val = d3.max(resp, function (d) {
                            //     return +d[key];
                            // });
                            //todo-fix: last data에서 기준을 가져오도록
                            // max_val_grouping_id = resp.filter(function (d) {
                            //     return +d[key] === max_val;
                            // });

                            if (max_val && max_val.gid && max_val.max) {
                                // max_val_grouping_id = max_val_grouping_id[0][cfg.data_grouping_key];
                                that.select("#chart-max-value")
                                    .text(data_format3s(max_val.max) + da.format_postfix)
                                    .style('fill', color(max_val.gid));
                            } else {
                                that.select("#chart-max-value")
                                    .text(data_format3s(0) + da.format_postfix)
                                    .style('fill', '#ffffff');
                            }

                            transitions = that.selectAll(".line")
                                .attr("d", function (d) { return da.pathgen(d.values); })
                                .attr("transform", null)
                                .transition()
                                .duration(duration)
                                .ease("linear")
                                .attr("transform", "translate(" + da.x(data_dt_first_min) + ")")
                                ;

                            // alarming
                            if (cfg.data_alarming) {
                                da.notification_triggers.forEach(function (t) {
                                    if (t.valid()) {
                                        t.feedobj(resp_g, da.alarm_callback, da.dealarm_callback);
                                    }
                                });
                            }
                        }
                    });


                    // pop the old data point off the front
                    data.map(function (d) {
                        while (d.values.length > n) {
                            d.values.shift();
                        }
                    });


                    data_dt_last_prev_max = data_dt_last_max;
                    data_dt_last_max = d3.ptree.grouping_data_last_max(data, '__time');
                    data_dt_first_min = data_dt_first_next_min;
                    data_dt_first_next_min = d3.ptree.grouping_data_first_next_min(data, '__time');

                }); //end of d3.tsv(resp)

            } //end of function tick

            //tick the data.
            tick();

        }); //end of d3.tsv(sample)

    } //end of function chart

    return chart;
};


d3.ptree.barchart = function (_cfg) {};

d3.ptree.notification = function (_cfg) {
    var cfg = _cfg;
    var limit_days = d3.set(cfg.limit_days);
    var limit_chain_val = {};
    // var time_formatter = d3.time.format("%H%M")
    var alarm = {};
    var alarmed = {};
    var noti = function (group_key, val, callback) {
        // function noti(group_key, val, callback) {
        console.log('Notification', cfg.key, group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        if (callback) {
            callback(cfg.key, group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        }
    };

    alarm.key = function () {
        return cfg.key;
    };

    alarm.feedobj = function (obj, alarm_cb, dealarm_cb) {
        //check each group
        var keys = d3.keys(obj);
        var val;
        var i;
        for (i = 0; i < keys.length; i++) {
            val = +obj[keys[i]][cfg.key];
            this.feedval(keys[i], val, alarm_cb, dealarm_cb);
        }
    };

    alarm.feedval = function (group_key, val, alarm_cb, dealarm_cb) {
        // console.log(group_key, val, cfg.limit, limit_chain_val[group_key], cfg.limit_chain_max);
        if (val >= cfg.limit) {
            if (!limit_chain_val[group_key]) {
                limit_chain_val[group_key] = 1;
            } else {
                limit_chain_val[group_key] += 1;
            }
        } else {
            limit_chain_val[group_key] = 0;
            if (alarmed[group_key]) {
                noti(group_key, val, dealarm_cb);
                alarmed[group_key] = false;
            }
        }
        if (limit_chain_val[group_key] >= cfg.limit_chain_max) {
            if (!alarmed[group_key]) {
                noti(group_key, val, alarm_cb);
                alarmed[group_key] = true;
            }
        }
    };

    alarm.valid = function () {
        var now = new Date(Date.now());
        var now_day = now.getDay();
        var now_hour = now.getHours();
        var now_min = now.getMinutes();
        var now_hm = "";
        if (now_min < 10) {
            now_min = "0" + now_min;
        }
        if (now_hour < 10) {
            now_hour = "0" + now_hour;
        }
        now_hm = now_hm + now_hour + now_min; //bugfixed - 조건문경유안할시 integer로 저장됨

        var v = false;
        //day check
        if (limit_days.has(now_day)) {
            v = true;
        } else {
            v = false;
        }
        //time check
        if (now_hm >= cfg.limit_time_range[0] && now_hm <= cfg.limit_time_range[1]) {
            v = true;
        } else {
            v = false;
        }
        // console.log('valid', v);
        return v;
    };

    return alarm;
};



// // // TWORLD
//  var __ptree_conf_tworld = d3.ptree.configuration();
//  __ptree_conf_tworld["system_name"] = "TWORLD";
//  __ptree_conf_tworld["data_get_url"] = "/__tsv_dataset/twor?action=pythonruntime";
//  // __ptree_conf_tworld['chart_type'] = 'bar';
//  __ptree_conf_tworld["data_alarming_triggers"] = [
//      d3.ptree.notification({key: 'logrds', limit: 400000, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
//      d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
//  ];
//  d3.ptree.rtchart(__ptree_conf_tworld)();


// // MVNO
// var __ptree_conf_mvno = d3.ptree.configuration();
// __ptree_conf_mvno["system_name"] = "MVNO";
// __ptree_conf_mvno["data_get_url"] = "/__tsv_dataset/mvno?action=pythonruntime";
// __ptree_conf_mvno["data_alarming_triggers"] = [
//     d3.ptree.notification({key: 'logrds', limit: 200000, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
//     d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
// ];
// d3.ptree.rtchart(__ptree_conf_mvno)();

// // TSHOPTGATE
// var __ptree_conf_tsho = d3.ptree.configuration();
// __ptree_conf_tsho["system_name"] = "TSHOPTGATE";
// __ptree_conf_tsho["data_get_url"] = "/__tsv_dataset/tsho?action=pythonruntime";
// __ptree_conf_tsho["data_alarming_triggers"] = [
//     d3.ptree.notification({key: 'logrds', limit: 150000, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
//     d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
// ];
// d3.ptree.rtchart(__ptree_conf_tsho)();


// // SMARTPLANNER
// var __ptree_conf_smtp = d3.ptree.configuration();
// __ptree_conf_smtp["system_name"] = "SMARTPLANNER";
// __ptree_conf_smtp["data_get_url"] = "/__tsv_dataset/smtp?action=pythonruntime";
// __ptree_conf_smtp["data_alarming_triggers"] = [
//     d3.ptree.notification({key: 'logrds', limit: 150000, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
//     d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
// ];
// d3.ptree.rtchart(__ptree_conf_smtp)();

/*
// RATER
var __ptree_conf_urtp = d3.ptree.configuration();
__ptree_conf_urtp["system_name"] = "RATER";
__ptree_conf_urtp["duration"] = 5000;
__ptree_conf_urtp["data_get_interval"] = 5000+100;
__ptree_conf_urtp["data_get_url"] = "/__tsv_dataset/urtp?action=pythonruntime";
__ptree_conf_urtp["data_alarming_triggers"] = [
        d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
];
__ptree_conf_urtp["print_key_name"] = true;
__ptree_conf_urtp["print_header"] = true;
__ptree_conf_urtp["width"] = (document.body.offsetWidth-20)/1;
__ptree_conf_urtp["data_key"] = ["logrds"];
__ptree_conf_urtp["chart_type"] = "area";
//d3.ptree.rtchart_column_header(__ptree_conf_urtp)();
d3.ptree.rtchart(__ptree_conf_urtp)();


// RATER
var __ptree_conf_urtp2 = d3.ptree.configuration();
__ptree_conf_urtp2["system_name"] = "RATER";
__ptree_conf_urtp2["duration"] = 5000;
__ptree_conf_urtp2["data_get_interval"] = 5000+100;
__ptree_conf_urtp2["data_get_url"] = "/__tsv_dataset/urtp?action=pythonruntime";
__ptree_conf_urtp2["data_alarming_triggers"] = [
        d3.ptree.notification({key: 'ApCo', limit: 30, limit_chain_max: 2, limit_time_range: ['0800','2200'], limit_days: [1,2,3,4,5]}),
];
__ptree_conf_urtp2["print_key_name"] = true;
__ptree_conf_urtp2["print_header"] = true;
__ptree_conf_urtp2["width"] = (document.body.offsetWidth-20)/4;
__ptree_conf_urtp2["data_key"] = ["logrds"];
__ptree_conf_urtp2["chart_type"] = "line";
d3.ptree.rtchart(__ptree_conf_urtp2)();
*/

// d3.ptree.rtchart(
// {
//     system_name: 'UKEYP-DISK-SUM',

//     //chart
//     width: document.body.offsetWidth-20,
//     height: 220,
//     margin: {top: 2, right: 0, bottom: 2, left: 0},
//     interpolate_method: "basis",
//     print_header: true,
//     print_key_name: false,
//     print_key_value: true,
//     duration: 5000,
//     data_get_interval: 5000+100, //duration보다 조금 길어야 graph가 자연스러워짐.

//     //data-manipulating
//     data_get_url: "/__tsv_dataset/ukyp_disk_sum?action=pythonruntime",
//     //data_timing_key: function (d) { var f = d3.time.format("%m/%d/%Y %H:%M:%S"); return f.parse(d._id); },  //null이면 data수집시간 기준으로 time value설정
//     data_timing_key: function (d) { return d3.ptree.std_dt_fmt.parse(d._id); },
//     data_grouping_key: null, //'inst_id', //null,//null이면 grouping없음
//     // data_filter: function (d) { return d['inst_id'] == 'ukyp6'; }, //null이면 filter없음
//     data_key: ["disk_phy_byte_sum"],
//     data_postfix: ["mb"],

//     //alarming
//     data_alarming: true,
//     data_alarming_triggers: [
//         d3.ptree.notification({key: 'disk_phy_byte_sum', limit: 40000, limit_chain_max: 2, limit_time_range: ['0000','2400'], limit_days: [1,2,3,4,5,6,7]}),
//     ],
// })();

// mvnop
d3.ptree.rtchart(
    (function () {
        var conf = d3.ptree.configuration();
        conf.system_name = 'MVNO';
        conf.data_key = 'deacon_mvno';
        conf.data_grouping_cnt = 2;
        return conf;
    }())
)();

// // ukyp-online
// d3.ptree.rtchart(
//     (function () {
//         var conf = d3.ptree.configuration();
//         conf.system_name = 'UKEYP-ONLINE';
//         conf.data_key = 'deacon_ukyp';
//         conf.data_grouping_cnt = 5;
//         return conf;
//     }())
// )();

// //ukyp-batch
// d3.ptree.rtchart(
//     (function () {
//         var conf = d3.ptree.configuration();
//         conf.system_name = 'UKEYP-BATCH';
//         conf.data_key = 'deacon_ukyp';
//         conf.data_grouping_cnt = 6;
//         conf.data_filter = function (d) { return d.inst_id === 'ukyp6'; };
//         return conf;
//     }())
// )();

// //EAIP
// d3.ptree.rtchart(
//     (function () {
//         var conf = d3.ptree.configuration();
//         conf.system_name = 'EAI';
//         conf.data_key = 'deacon_eaip';
//         conf.data_grouping_cnt = 2;
//         return conf;
//     }())
// )();

// // MCGP
// d3.ptree.rtchart(
//     (function () {
//         var conf = d3.ptree.configuration();
//         conf.system_name = 'MCG';
//         conf.data_key = 'deacon_mcgp';
//         conf.data_grouping_cnt = 2;
//         return conf;
//     }())
// )();

// // SSO
// d3.ptree.rtchart(
//     (function () {
//         var conf = d3.ptree.configuration();
//         conf.system_name = 'SKTSSO';
//         conf.data_key = 'deacon_ssop';
//         conf.data_grouping_cnt = 2;
//         return conf;
//     }())
// )();


// d3.ptree.rtchart(
// {
//     system_name: 'UKEYP-DISK-SUM',

//     //chart
//     width: document.body.offsetWidth-20,
//     height: 330,
//     margin: {top: 2, right: 0, bottom: 2, left: 0},
//     interpolate_method: "basis",
//     print_header: true,
//     print_key_name: false,
//     print_key_value: true,
//     chart_type: 'bar',

//     //time-range
//     n: 590,
//     duration: 5000,
//     data_get_interval: 5000+100, //duration보다 조금 길어야 graph가 자연스러워짐.

//     //data-manipulating
//     data_get_url: "/__tsv_dataset/ukyp_disk_sum?action=pythonruntime",
//     data_grouping_key: null,//null이면 grouping없음
//     data_filter: null, //null이면 filter없음
//     data_key: ["disk_phy_byte_sum"],
//     data_postfix: ["mb"],

//     //alarming
//     data_alarming: true,
//     data_alarming_triggers: [
//         d3.ptree.notification({key: 'disk_phy_byte_sum', limit: 40000, limit_chain_max: 2, limit_time_range: ['0000','2400'], limit_days: [1,2,3,4,5,6,7]}),
//     ],
// })();

var glance_data_keys = [
            {key: 'cpu',        postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line',
                notifications: [
                    {limit: 90, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
                ]},
            {key: 'mem',        postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
            {key: 'disk',       postfix: '%', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line',
                notifications: [
                    {limit: 90, limit_chain_max: 2, limit_time_range: ['0800', '2200'], limit_days: [1, 2, 3, 4, 5]}
                ]},
            {key: 'disk_phy_read_byte',  postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
            {key: 'disk_phy_write_byte', postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
            {key: 'disk_phy_byte',       postfix: 'mb', width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line'},
            {key: 'ref_cpu',              postfix: '%',  width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line', dailyref: 'cpu' },
            {key: 'ref_disk',             postfix: '%',  width: (document.body.offsetWidth - 20) / 16 * 8, height: 88, charttype: 'line', dailyref: 'disk' }
        ];

// // d3.ptree.rtchart((function () { var conf = d3.ptree.configuration(); conf.data_columns = glance_data_keys; conf.duration = 5000; conf.n = 90; conf.system_name = 'UKEYP-DISK'; conf.data_key = 'glance_ukyp'; conf.data_grouping_cnt = 4; return conf; }()))();
d3.ptree.rtchart((function () { var conf = d3.ptree.configuration(); conf.data_columns = glance_data_keys; conf.duration = 5000; conf.n = 90; conf.system_name = 'UKEYX-DISK'; conf.data_key = 'glance_ukyx2'; conf.data_grouping_cnt = 1; return conf; }()))();
